package generated_models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// OrderDetail represents a row from 'prototestdb123.OrderDetails'.
type OrderDetail struct {
	OrderID   int       `json:"order_id"`   // order_id
	ProductID int       `json:"product_id"` // product_id
	Quantity  int       `json:"quantity"`   // quantity
	CreatedAt time.Time `json:"created_at"` // created_at
	UpdatedAt time.Time `json:"updated_at"` // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [OrderDetail] exists in the database.
func (od *OrderDetail) Exists() bool {
	return od._exists
}

// Deleted returns true when the [OrderDetail] has been marked for deletion
// from the database.
func (od *OrderDetail) Deleted() bool {
	return od._deleted
}

// Insert inserts the [OrderDetail] to the database.
func (od *OrderDetail) Insert(ctx context.Context, db DB) error {
	switch {
	case od._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case od._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO prototestdb123.OrderDetails (` +
		`order_id, product_id, quantity, created_at, updated_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, od.OrderID, od.ProductID, od.Quantity, od.CreatedAt, od.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, od.OrderID, od.ProductID, od.Quantity, od.CreatedAt, od.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	od._exists = true
	return nil
}

// Update updates a [OrderDetail] in the database.
func (od *OrderDetail) Update(ctx context.Context, db DB) error {
	switch {
	case !od._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case od._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE prototestdb123.OrderDetails SET ` +
		`quantity = ?, created_at = ?, updated_at = ? ` +
		`WHERE order_id = ? AND product_id = ?`
	// run
	logf(sqlstr, od.Quantity, od.CreatedAt, od.UpdatedAt, od.OrderID, od.ProductID)
	if _, err := db.ExecContext(ctx, sqlstr, od.Quantity, od.CreatedAt, od.UpdatedAt, od.OrderID, od.ProductID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [OrderDetail] to the database.
func (od *OrderDetail) Save(ctx context.Context, db DB) error {
	if od.Exists() {
		return od.Update(ctx, db)
	}
	return od.Insert(ctx, db)
}

// Upsert performs an upsert for [OrderDetail].
func (od *OrderDetail) Upsert(ctx context.Context, db DB) error {
	switch {
	case od._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO prototestdb123.OrderDetails (` +
		`order_id, product_id, quantity, created_at, updated_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`order_id = VALUES(order_id), product_id = VALUES(product_id), quantity = VALUES(quantity), created_at = VALUES(created_at), updated_at = VALUES(updated_at)`
	// run
	logf(sqlstr, od.OrderID, od.ProductID, od.Quantity, od.CreatedAt, od.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, od.OrderID, od.ProductID, od.Quantity, od.CreatedAt, od.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	od._exists = true
	return nil
}

// Delete deletes the [OrderDetail] from the database.
func (od *OrderDetail) Delete(ctx context.Context, db DB) error {
	switch {
	case !od._exists: // doesn't exist
		return nil
	case od._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM prototestdb123.OrderDetails ` +
		`WHERE order_id = ? AND product_id = ?`
	// run
	logf(sqlstr, od.OrderID, od.ProductID)
	if _, err := db.ExecContext(ctx, sqlstr, od.OrderID, od.ProductID); err != nil {
		return logerror(err)
	}
	// set deleted
	od._deleted = true
	return nil
}

// OrderDetailByOrderIDProductID retrieves a row from 'prototestdb123.OrderDetails' as a [OrderDetail].
//
// Generated from index 'OrderDetails_order_id_product_id_pkey'.
func OrderDetailByOrderIDProductID(ctx context.Context, db DB, orderID, productID int) (*OrderDetail, error) {
	// query
	const sqlstr = `SELECT ` +
		`order_id, product_id, quantity, created_at, updated_at ` +
		`FROM prototestdb123.OrderDetails ` +
		`WHERE order_id = ? AND product_id = ?`
	// run
	logf(sqlstr, orderID, productID)
	od := OrderDetail{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, orderID, productID).Scan(&od.OrderID, &od.ProductID, &od.Quantity, &od.CreatedAt, &od.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &od, nil
}
